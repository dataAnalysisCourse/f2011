function s = vector_to_struct(input)
% The function converts a mx1 vector of doubles (which must have been parsed
% with the method struct_to_vector) back into the original structure.
%
%Input: input (mx1) - vector corresponding to the encoding of a structure.
%Output: s = structure
%
%See comments in the function 'struct_to_vector' has to how the original structure was
%parsed into a mx1 vector. The code in this function recursively reconstructs the original
%structure.
%
%There is miminal error checking regarding the input vector. However, if the 1st element is
%not FIELD_NAME_CODE, the function returns the empty matrix. As simulink sometimes passes in
%zero input during initialization, you should check that the output to this function is not
%empty. (As may occur during simulink start-up)
%
%Ver 1.0, Eric Olsen, JHU/APL 10/16/02

FIELD_NAME_CODE = 1000;      %code for field name

if(input(1) ~= FIELD_NAME_CODE)
  s=[]; 
else
  [s, ep]=get_struct(input');
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function [s,ep] = get_struct(input)
%The function parses the input vector (which must have been generated by struct_to_vector) into the
%asssociated data elements.
%
%s - data element
%ep - number of elements of the vector 'input' used to reconstruct the data element s
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [s,ep] = get_struct(input)
%parsing codes
FIELD_NAME_CODE = 1000;      %code for field name
NUMERIC_ARRAY_CODE = 2000;   %code for array 
STRING_CODE = 3000;          %code for string
CELL_CODE = 4000;            %code for cell 
END_STRUCT_FIELDS = 5000;    %code to indicate the fields of the current structure being parsed is done.

s=[]; 
index=1;

while(1)
  switch( input(index) )
     case  NUMERIC_ARRAY_CODE                     %parse numeric array
         num_dimensions = input(index+1);         %number of array dimensions
         dimensions = input(index+2:index+1+num_dimensions);  %dimensions of array
         num_elements = prod(dimensions);         %total number of elelments in array
         start_data_index = index + 2 + num_dimensions;   %start index of array data
         end_data_index = start_data_index - 1 + num_elements;  %end element of array data
         if(num_elements > 1)
           s=reshape(input(start_data_index:end_data_index)', dimensions); 
         elseif(num_elements==1)
           s = input(start_data_index:end_data_index);
         else  %empty array
           s=[];  
         end;  
         ep = 2 + num_dimensions +  num_elements; % total number of elements of input vector which were processed 
                                                  %in order to reconstruct the array 
         return;
     case STRING_CODE                        %parse string
         length_string = input(index+1);    %get the number of characters in string
         s = char(input(index+2:index+length_string+1)); %reconstruct string
         ep = 2 + length_string;  % total number of elements of input vector which were processed 
                                  %in order to reconstruct the string
         return;                         
     case CELL_CODE %parse cell
          num_dimensions = input(index+1);                     %number of cell dimensions
          dimensions = input(index+2:index+1+num_dimensions);  %dimensions of cell
          s=cell(dimensions);                                  %initialize cell
          num_elements = prod(dimensions);                     %total number of elements in cell
          index = index + num_dimensions + 2;                  %jump to the next data code after CELL_CODE
          for i=1:num_elements                                 %extract elements of cell
            cell_array_index_as_string = get_cell_as_string(i,dimensions);
            [cell_data,ep] = get_struct(input(index:end));     %recursive call
            eval([cell_array_index_as_string,'=cell_data;']);
            index = index+ep;
          end;
          ep=index-1;
          return;
      case FIELD_NAME_CODE   %parse field 
          length_name = input(index+1); %get the number of characters in string
          field_name =  char(input(index+2:index+1+length_name)); %get field name
          start_index = index+length_name+2;
          [field_data , ep] = get_struct(input(start_index:end)); %get data for field
          s=setfield(s,field_name,field_data); 
          index = start_index+ep;            %go to next data code entry
     case END_STRUCT_FIELDS   %The fields of the current structure being parsed are done.
          ep = index;
          return;
    end;   %end switch 
   
end;    %end while    
ep = index;      

    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function  cell_string = get_cell_as_string(index,dimensions)
%Returns indexing into cell, s, as a string. For example, assume the cell has dimensions
%of (2,2,2). If the input 'index' corresponds to the element (2,2,1) (which is index=4), the
%function returns the string 's{2,2,1}'. The dimension corresponding to the element 'index' is
%derived based on the cell having been parsed as a list, s{:}.
%
%Input: index = element number (scalar) of cell,s, to be indexed into when the cell is parsed
%               as a list using s(:). 
%       dimensions: The dimensions of the cell (1xn)
%Output: The string corresponding to indexing into the element given by the input 'index' using
%        cell dimensions given by input 'dimensions'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function  cell_string = get_cell_as_string(index,dimensions)

num_dimensions = length(dimensions);
num_elements = prod(dimensions);
base=cumprod(dimensions);
  
dim=ones(num_dimensions,1);  % initialize dimensions corresponding to index

%need to reconstruct indices into the cell
while(index>0)
  dim_index=min(find(index<=base)); 
  if(dim_index>1)
    dim(dim_index)= floor((index-1)/base(dim_index-1))+1;
    index=index - base(dim_index-1)*(dim(dim_index)-1);
  else
    dim(1)=index;
    index=0;
  end;
end;

%create string representation
cell_string='s{';
for i=1:num_dimensions
  if(i<num_dimensions)
   cell_string=[cell_string,num2str(dim(i)),','];  
  else
    cell_string=[cell_string,num2str(dim(i))];
  end;
end;
cell_string=[cell_string,'}'];
   
  
  
  
  
  
  
  