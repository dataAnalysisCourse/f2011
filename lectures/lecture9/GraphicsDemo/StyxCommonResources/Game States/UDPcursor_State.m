classdef UDPcursor_State < StyxState
	% When this state is made true, the cursor movement and click events are
	% generated by this state periodically checking for UDP packets
	% containing a x,y,z velocity and click boolean.
	%
	% Also sends a discontinuity flag (-1) via gameUDP to notify BG2
	% System_Core that the cursor did not move exactly according the the
	% latest velocity command. This usually happens when it hits the edge
	% of the workspace and is prevented from leaving the screen.
	%
	% Can be linked to a transition event using the LinkToTransitionEvt
	% method. This adds a listener to this event, and when it happens the
	% State transitions to its NextState(1). This is usually used to jump
	% the cursor after a target acquisition or timedout.
	%
	% Initialization:
	%         * needs to be given the handle of the cursor in its cursor_h
	%         property and the gameUDP object that this state uses to
	%         receive commands.
	%
	% *****************************************************
	%                       PROPERTIES
	% *****************************************************
	properties (Access = public)
		rate = 30;          % how many times per second to move the cursor
							% Note that UDPcursor_State holds the most
							% recent velocity received via UDP, so if the
							% rate here exceeds the rate that decoded
							% velocity is provided to the game, this will
							% in effect upsample the kinematics!
		holdDiscontinuityNsteps = 2; % when a discontinuity is sent, the all 
		                    % clear signal is sent on the Nth step. The
		                    % intention is that holdDiscontinuityNsteps is
		                    % large enough in comparison to rate that it is
		                    % guaranteed that the simulink core receives
		                    % the discontinuity. Thus, if rate is 30 and
		                    % SLC is running every 50ms, this property must
		                    % be >= 2 so the discontinuity flag is not
		                    % overwritten faster than every 66ms.
		
		clickCausesDiscontinuity = true; % if true, then when a click command
		% is decoded send the discontinuity flag which
		% zeros the kinematics in the Kalman to erase
		% inertia.
		sendingCursorPos = false; % if true, after each cursor movement
		% sends back POSITION using cursorPosUDP object. If set to true 
        % make sure cursorPosUDP handle is provided.
	end %properties (Access = public)
	properties (Access = private)
		gameUDP               % StyxUDPcommunicator object handle that this
		% state uses to receive velocity in to game
		% and send discontinuity flag out.
		cursorPosUDP          % StyxUDPcommunicator object handle that this state
		% uses to send cursor position if sendingCursorPos is true.
		cursor_h
		timer_h % the timer object that periodically checks for incoming UDP
		% cursor commands.
		discontinuity = false;%  state uses this to mark that it has entered a
		%  discontinuity such as jumping cursor
		%  position to avoid leaving the workspace.
		%  Keeping track of this between timer calls
		%  lets it know when it has left a
		%  discontinuity and can send the
		%  corresponding flag out via UDP.
		lh_array              %  Array for listener handles.
		%  The listener(s) can listen for
		%  a pauseUDPcursor event (for example when
		%  autopilot takes over) and call the
		%  UDPpauseEvt method, which calls this
		%  state's first nextStateChoice (which is
		%  intended to be the cursor jump or autopilot
		%  state).
		currVelocity = [0 0 0] % I keep track of the current velocity (in game units/sec) and update with new UDP commands
		clearDiscontinuityCounter = 0; % used in conjunction with 
	end %properties (Access = private)
	
	% *****************************************************
	%                       METHODS
	% *****************************************************
	methods (Access = public)
		function obj = UDPcursor_State( varargin )
			% Note that StyxState immediately calls InitializeState method
			% after the constructor.
			obj = obj@StyxState(varargin);
		end %function obj =  Pause_State ( )
		
		function obj = InitializeState( obj, varargin )
			% InitializeState is a pseudo constructor, with the advantage
			% of it being able to be called from without to "reset" this
			% state.
			propAndValues = varargin{1}; % unpack property-value pairs
			for i = 1: 2 : length(propAndValues)
				obj.(propAndValues{i}) = propAndValues{i+1};
			end
			obj.timer_h = timer(...
				'TimerFcn', { @obj.UDPcursor_TimerFcn },  ...
				'BusyMode', 'drop', 'TasksToExecute', Inf, ...
				'ExecutionMode', 'fixedRate', 'Period', 1/obj.rate , ...
				'StartDelay', 1/obj.rate, ...
				'Name', 'UDPcursorTimer');
		end %function obj = InitializeState()
		
		function obj = FalseToTrueImplement( obj )
			% enable the listener(s) to transition events
			for i = 1 : length( obj.lh_array)
				obj.lh_array{i}.Enabled = true;
			end
			
			obj.currVelocity = [0 0 0]; % reset to zero velocity until a UDP vel command is received.
			% send discontinuity flag to reset Kalman history right when
			% cursor control is enabled. Prior to this the cursor wasn't
			% moving so any decoded history it might've built up is
			% meaningless.
			obj.discontinuity = true;
			obj.SendDiscontinuityFlag;
			
			% start the timer which generates cursor movements
			start( obj.timer_h );
		end
		
		function obj = TrueToFalseImplement( obj )
			% enable the listener(s) to transition events
			for i = 1 : length( obj.lh_array)
				obj.lh_array{i}.Enabled = false;
			end
			% stop timer which generations cursor movements
			stop( obj.timer_h );
		end
		
		function obj = LinkToTransitionEvt( obj, CallingObj, eventName )
			% adds a listener to the CallingObj's event of name eventName
			% which will call this state's TransitionEvt method. Used to
			% listen to events that would cause the UDPcursor_State to need
			% to transition to its next state, for example the cursor
			% should jump and not be under UDP control, or be controlled by
			% an autopilot of some sort.
			obj.lh_array{end+1} = addlistener( CallingObj, eventName, @obj.TransitionEvt );
			obj.lh_array{end}.Enabled = false; % starts not listening when this state is not true. WIll be turned on in FalseToTrueImplement
		end %function obj = LinkToTransitionEvt( obj, CallingObj, eventName )
		
		% DESTRUCTOR
		function delete(obj)
			stop(  obj.timer_h )
			delete( obj.timer_h )
			for i = 1 : length( obj.lh_array)
				if isobject( obj.lh_array{i} )
					delete( obj.lh_array{i} )
				end
			end
		end %function delete(obj)
	end %methods (Access = public)
	
	methods (Access = private)
		function TransitionEvt( obj, eventSrc, eventData )
			% When this state is notified of a transition event, such as a
			% Fitts target being jumped or autopilot-inducing event, it
			% transitions to its first nextStateChoices.
			
			% send discontinuity packet to model core to signify that
			% continuous cursor reaction to velocity commands is being
			% interrupted.
			obj.discontinuity = true;
			obj.SendDiscontinuityFlag
			% Transition to the next state.
			NextState( obj, 1 );
		end
		
		function UDPcursor_TimerFcn( obj, timerObj, event )
			% This is the timer function for this state's internal timer
			% object. When the state is true, the timer is running. Much of
			% the work of the function actually happens here: the Cursor is
			% moved and clicks executed.
			
			click_in = 0; % no click by default unless we receive a click.
			% Get the incoming packet of instructions. Expected format is
			% | packetID | timestamp|  cursor x | cursor y | cursor z | cursor click | pad 0 up to 64 elements|
			receivedPacket = StyxReceiveUDP( obj.gameUDP );
			if ~isempty( receivedPacket )
				if receivedPacket(1) == 11 % expected Styx cursor packetID
					obj.currVelocity = receivedPacket(3:5); %V_x V_y V_z
					click_in = receivedPacket(6);
				else
					error('PacketID of receivedPacket is %i. Expecting 11 for Styx game.', receivedPacket(1)')
				end
				% log the simulation timestamp sent by the BG2Core that
				% came with this receivedPacket. This allows the styxGame to
				% be synchronized (roughly) to the files saved by BG2Core.
				Log( obj.logger_h, obj, 'SYNC', 'kinReceiveSimStep', receivedPacket(2) );
			end
			
			% now move the cursor
			deltaPosition = obj.currVelocity .* timerObj.Period;
			newXYZ = obj.cursor_h.xyz + deltaPosition;
			% cursor cannot leave workspace, so check and enforce.
			% Do it vectorized, 'cuz that's how we roll.
			minBoundary = [ obj.cursor_h.world_h.xlim(1) obj.cursor_h.world_h.ylim(1) obj.cursor_h.world_h.zlim(1) ]...
				+ obj.cursor_h.radius; % last term so that half the cursor won't go off screen.
			maxBoundary = [ obj.cursor_h.world_h.xlim(2) obj.cursor_h.world_h.ylim(2) obj.cursor_h.world_h.zlim(2) ]...
				- obj.cursor_h.radius;
			
			tooLow = newXYZ < minBoundary;
			newXYZ(tooLow) = minBoundary(tooLow);
			tooHigh = newXYZ > maxBoundary;
			newXYZ(tooHigh) = maxBoundary(tooHigh);
			% if I didn't perfectly execute the velocity instructions
			% (i.e. i jumped position to avoid going off screen) let the
			% BG2 core know so that models can zero Kalman system prior,
			% for example
			if any( [tooLow tooHigh ] )
				obj.discontinuity = true; % mark that a discontinuity in
				% obeying velocity command has
				% happened.
				obj.SendDiscontinuityFlag; % all clear
			else
				if obj.discontinuity == true
					obj.discontinuity = false;
					obj.SendDiscontinuityFlag; % all clear
				end
			end%if any( [tooLow tooHigh ] )
			
			% actually go ahead and move the cursor
			SetXYZ( obj.cursor_h, newXYZ );
			
			% if click is detected, click!
			if click_in == 1;
				Click( obj.cursor_h );
				if obj.clickCausesDiscontinuity
					% click should cause discontinuity event to reset
					% Kalman velocity.
					obj.clearDiscontinuityCounter = 0; % reset this counter.
					obj.discontinuity = true;
					obj.SendDiscontinuityFlag;
				end
			end
			
			% TODO: I need to figure out the discontinuity situation so if
			% my upsampling is very fast I make sure to send the
			% discontinuity enough steps that it is received by SLC!!
			
			% for weird case where discontinuity happened but no UDP control received.
			if obj.discontinuity == true
				obj.clearDiscontinuityCounter = obj.clearDiscontinuityCounter + 1;
				if obj.clearDiscontinuityCounter >= obj.holdDiscontinuityNsteps
					obj.discontinuity = false;
					obj.SendDiscontinuityFlag; % all clear
				end
			end
			
            % send cursor position to SLC
            if obj.sendingCursorPos
                sendCursorPos( obj )
            end
			
		end %UDPcursor_TimerFcn( obj, timerObj, event )
		
		function SendDiscontinuityFlag( obj )
			% I package up the code for actually sending the discontinuity flag
			% here since's its called in more than one place. This way if
			% formatting changes, it's all here. Flag is either -1 for when a
			% discontinuity happens or 0 for when no discontinuity happens.
			if obj.discontinuity
				flag = -1;
			else
				flag = 0;
			end
			sendPacket = zeros(1,64); % The convention is to send 64 double packets
			sendPacket(1:3) = [12 datenum(clock) flag];
			StyxSendUDP( obj.gameUDP, sendPacket );
		end % function SendDiscontinuityFlag
		
		function sendCursorPos( obj )
            % Send back cursor position to SLC
			sendPacket = zeros(1,64); % The convention is to send 64 double packets
			sendPacket(1:5) = [15 datenum(clock) obj.cursor_h.xyz];
			StyxSendUDP( obj.cursorPosUDP, sendPacket );
		end % function sendCursorPos
	end %methods (Access = private)
	
end %classdef
